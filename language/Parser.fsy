%{
open AST

%}

// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token LET SEPERATOR ECHO LCB RCB UNIT DOT COLON WITH REC TYPE
%token ARROW LPAR RPAR LSQBR RSQBR COMMA
%token EQUALS NOT BIGGER SMALLER
%token PLUS MIN TIMES DIVIDE
%token QUESTION ELSE AND OR
%token < string > ID
%token < string > STRING
%token < int32 > INT
%token < bool > BOOL
%token EOF
%token OPEN

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Expression list > start

%%

// These are the rules of the grammar along with the F# code of the
// actions executed as rules are reduced.
start: program EOF { $1 }

program:
  | expression                                        { [$1] }
  | expression program                                { $1 :: $2 }

atomic:
  | INT                                               { Int $1 }
  | BOOL                                              { Bool $1 }
  | UNIT                                              { Unit () }
  | STRING                                            { String $1 }

expression:
  | LET ID TYPE typing EQUALS expression0             { Write ($2, $6, false, $4) }
  | LET REC ID TYPE typing EQUALS expression0         { Write ($3, $7, true, $5) }
  | ECHO expression0                                  { Echo $2 }
  | expression0                                       { $1 }

expression0:
  | OPEN ID                                           { Open $2 }
  | expression0 AND expression1                       { And ($1, $3) }
  | expression0 OR expression1                        { Or ($1, $3) }
  | expression1                                       { $1 }

expression1:
  | expression1 QUESTION expression1 COLON expression1 { Condition ($1, $3, $5) }
  | expression1 EQUALS EQUALS expression2             { Equals ($1, $4)}
  | expression1 NOT EQUALS expression2                { NotEquals ($1, $4)}
  | expression2                                       { $1 }

expression2:
  | expression2 PLUS expression3                      { Plus ($1, $3) }
  | expression2 MIN expression3                       { Min ($1, $3) }
  | expression3                                       { $1 }

expression3:
  | expression3 TIMES expression4                     { Times ($1, $3) }
  | expression3 DIVIDE expression4                    { Divide ($1, $3) }
  | expression4                                       { $1 }

expression4:
  | lambda                                            { $1 }
  | expression4 DOT LSQBR expression1 RSQBR           { ArrayGet ($1, $4) }
  | typing LSQBR expr_list RSQBR                      { ArrayInit ($3, $1) }
  | typing LSQBR RSQBR                                { ArrayInit ([], $1) }
  | expression4 DOT ID                                { ObjectGet ($1, $3) }
  | expression4 LPAR expression1 RPAR                 { Apply ($1, $3) }
  | atomic                                            { Value $1 }
  | ID                                                { Read $1 }
  | LCB prop_list RCB                                 { ObjectInit $2 }
  | LCB expression4 WITH ID COLON expression1 RCB     { ObjectCopyWith ($2, ($4, $6))} 
  | LCB expression RCB                                { Nested $2 }

expr_list:
  | expression                                        { [$1] }
  | expression COMMA expr_list                        { $1 :: $3 }

prop_list: 
  | ID COLON expression1                              { [($1, $3)] }
  | ID COLON expression1 COMMA prop_list              { ($1, $3) :: $5 }

lambda:
  | ID TYPE typing ARROW LCB program RCB              { Lambda ($1, $3, $6)}
  | ID TYPE typing ARROW expression                   { Lambda ($1, $3, [$5])}

typing: 
  | ID                                                 { NamedType $1 }
  | STRING                                             { StringLiteral $1 |> LiteralType }
  | BOOL                                               { BoolLiteral $1 |> LiteralType }
  | INT                                                { IntLiteral $1 |> LiteralType }
  | UNIT                                               { LiteralType UnitLiteral }
  | typing ARROW typing                                { FuncType ($1, $3) }
  | LPAR typing RPAR                                   { NestedType $2 }
  | typing LSQBR RSQBR                                 { ArrayType $1}