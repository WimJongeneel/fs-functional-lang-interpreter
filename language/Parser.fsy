%{
open AST

%}

// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token LET SEPERATOR ECHO LCB RCB UNIT DOT COLON WITH
%token ARROW LPAR RPAR LSQBR RSQBR COMMA
%token EQUALS NOT BIGGER SMALLER
%token PLUS MIN TIMES DIVIDE
%token QUESTION ELSE
%token < string > ID
%token < string > STRING
%token < int32 > INT
%token < bool > BOOL
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Expression list > start

%%

// These are the rules of the grammar along with the F# code of the
// actions executed as rules are reduced.
start: program EOF { $1 }

program:
  | expression                                        { [$1] }
  | expression program                                { $1 :: $2 }

atomic:
  | INT                                               { Int $1 }
  | BOOL                                              { Bool $1 }
  | UNIT                                              { Unit () }

expression:
  | LET ID EQUALS expression1                         { Write ($2, $4) }
  | ECHO expression1                                  { Echo $2 }
  | expression1                                       { $1 }

expression1:
  | expression1 QUESTION expression1 ELSE expression1 { Condition ($1, $3, $5) }
  | expression1 EQUALS EQUALS expression2             { Equals ($1, $4)}
  | expression1 NOT EQUALS expression2                { NotEquals ($1, $4)}
  | expression2                                       { $1 }

expression2:
  | expression2 PLUS expression3                      { Plus ($1, $3) }
  | expression2 MIN expression3                       { Min ($1, $3) }
  | expression3                                       { $1 }

expression3:
  | expression3 TIMES expression4                     { Times ($1, $3) }
  | expression3 DIVIDE expression4                    { Divide ($1, $3) }
  | expression4                                       { $1 }

expression4:
  | lambda                                            { $1 }
  | expression4 DOT LSQBR expression1 RSQBR           { ArrayGet ($1, $4) }
  | LSQBR expr_list RSQBR                             { ArrayInit $2 }
  | expression4 DOT ID                                { ObjectGet ($1, $3) }
  | expression4 LPAR expression1 RPAR                 { Apply ($1, $3) }
  | atomic                                            { Value $1 }
  | ID                                                { Read $1 }
  | LCB prop_list RCB                                 { ObjectInit $2 }
  | LCB expression4 WITH ID COLON expression1 RCB     { ObjectCopyWith ($2, ($4, $6))} 
  | LCB expression RCB                                { Nested $2 }

expr_list:
  | expression                                        { [$1] }
  | expression COMMA expr_list                        { $1 :: $3 }

prop_list: 
  | ID COLON expression1                              { [($1, $3)] }
  | ID COLON expression1 COMMA prop_list              { ($1, $3) :: $5 }

lambda:
  | ID ARROW LCB program RCB                          { Lambda ($1, $4)}
  | ID ARROW expression                               { Lambda ($1, [$3])}